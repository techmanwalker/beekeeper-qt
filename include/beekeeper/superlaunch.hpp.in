#pragma once
/**
 * superlaunch.hpp
 *
 * This class is responsible ONLY for lifecycle management of the privileged
 * helper shell. It asks for authorization (Polkit later), forks the root shell,
 * and tears it down when done. It does NOT execute beekeeperman commands —
 * that is exclusively SuperCommander’s job.
 */

#include <mutex>
#include <sys/types.h> // for pid_t

// -------------------- privileged helper path --------------------.
#define BEEKEEPER_HELPER_PATH "@BEEKEEPER_HELPER_PATH@"

// forward-declare the supercommander type so we can return references without including its header
namespace beekeeper { namespace privileged { class supercommander; } }

class superlaunch
{
public:
    static superlaunch& instance()
    {
        static superlaunch inst;
        return inst;
    }

    ~superlaunch();

    // Top-level entry points: these acquire the mutex (mtx_) and then call
    // the corresponding _unlocked helper to do actual work without nested locking.
    bool start_root_shell();
    bool stop_root_shell();
    bool root_shell_alive();

    beekeeper::privileged::supercommander& create_commander();

private:
    superlaunch() = default;            // private constructor
    superlaunch(const superlaunch&) = delete;
    superlaunch& operator=(const superlaunch&) = delete;

    // _unlocked helpers: do the real work but MUST NOT lock mtx_ (caller locks).
    // These are private to avoid accidental external calls without locking.
    bool root_shell_alive_unlocked();
    bool start_root_shell_unlocked();
    bool stop_root_shell_unlocked();

    std::mutex mtx_;
};
